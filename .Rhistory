win_rate_observed = 2)
print(df_true_rates)
true_w_rates <- tournament_stats_truewinrate(10000)
df_true_rates <- bootstrap_problem_two(n_straps = 1000, store = true_w_rates)
df_true_rates$diff <- df_true_rates$win_rate_observed - df_true_rates$probability_theoretical
df_true_rates$win_rate_observed - df_true_rates$probability_theoretical
true_w_rates <- tournament_stats_truewinrate(10000)
View(true_w_rates)
df_true_rates <- bootstrap_problem_two(n_straps = 1000, store = true_w_rates)
View(df_true_rates)
true_w_rates <- tournament_stats_truewinrate(10000)
df_true_rates <- bootstrap_problem_two(n_straps = 1000, store = true_w_rates)
df_true_rates$diff <- df_true_rates$average_value - df_true_rates$Prob
df_true_rates <- df_true_rates%>%
rename(probability_theoretical = 1,
win_rate_observed = 2,
difference = 3)
print(df_true_rates)
df_true_rates %>%
ggplot(aes(x = probability_theoretical, y = win_rate_observed))+
geom_point()+
scale_x_continuous(name="theoretical win rates", limits=c(0.1, 0.9),
n.breaks = 9)+
scale_y_continuous(name="average observed win rates", limits=c(0.0, 1.0),
n.breaks = 11)+
ggtitle("Average observed win rate in relation to a fixed theoretical win rate")+
theme(plot.title = element_text(hjust= 0.5))
df_true_rates %>%
ggplot(aes(x = probability_theoretical, y = win_rate_observed))+
geom_point()+
scale_x_continuous(name="theoretical win rates", limits=c(0.1, 0.9),
n.breaks = 9)+
scale_y_continuous(name="average observed win rates", limits=c(0.0, 1.0),
n.breaks = 11)+
ggtitle("Average observed win rate in relation to a fixed theoretical win rate")+
theme(plot.title = element_text(hjust= 0.5))+
geom_line(aes(y=x))
df_true_rates %>%
ggplot(aes(x = probability_theoretical, y = win_rate_observed))+
geom_point()+
scale_x_continuous(name="theoretical win rates", limits=c(0.1, 0.9),
n.breaks = 9)+
scale_y_continuous(name="average observed win rates", limits=c(0.0, 1.0),
n.breaks = 11)+
ggtitle("Average observed win rate in relation to a fixed theoretical win rate")+
theme(plot.title = element_text(hjust= 0.5))+
abline(1,2)
df_true_rates %>%
ggplot(aes(x = probability_theoretical, y = win_rate_observed))+
geom_point()+
scale_x_continuous(name="theoretical win rates", limits=c(0.1, 0.9),
n.breaks = 9)+
scale_y_continuous(name="average observed win rates", limits=c(0.0, 1.0),
n.breaks = 11)+
ggtitle("Average observed win rate in relation to a fixed theoretical win rate")+
theme(plot.title = element_text(hjust= 0.5))+
geom_abline(slope = 1)
df_true_rates %>%
ggplot(aes(x = probability_theoretical, y = win_rate_observed))+
geom_point()+
scale_x_continuous(name="theoretical win rates", limits=c(0.1, 0.9),
n.breaks = 9)+
scale_y_continuous(name="average observed win rates", limits=c(0.0, 1.0),
n.breaks = 11)+
ggtitle("Average observed win rate in relation to a fixed theoretical win rate")+
theme(plot.title = element_text(hjust= 0.5))+
geom_abline(slope = 1, colour = "red")
# declaring p
p <- 0.75
#simulations one single tournament
results <- tournament_sim(p_win = p)
# declaring p
p <- 0.75
#simulations one single tournament
results <- tournament_sim(p_win = p)
(1-0.1)^3
1/4
0.073104554/0.4
0.073/0.4
0.5^7
0.5^3
3/9
4/9
9*0.4
(1-0.4)^3
(7/9)*100
tournament_sim(0.7777778)[3]
tournament_sim(0.7777778)[3]
tournament_sim(0.7777778)[3]
tournament_sim(0.7777778)[3]
tournament_sim(0.7777778)[3]
tournament_sim(0.7777778)[3]
tournament_sim(0.7777778)[3]
tournament_sim(0.7777778)[3]
tournament_sim(0.7777778)[3]
tournament_sim(0.7777778)[3]
tournament_sim(0.7777778)[3]
tournament_sim(0.7777778)[3]
tournament_sim(0.7777778)[3]
tournament_sim(0.7777778)[3]
tournament_sim(0.7777778)[3]
tournament_sim(0.7777778)[3]
tournament_sim(0.7777778)[3]
tournament_sim(0.7777778)[3]
tournament_sim(0.7777778)[3]
tournament_sim(0.7777778)[3]
tournament_sim(0.7777778)[3]
tournament_sim(0.7777778)[3]
tournament_sim(0.7777778)[3]
tournament_sim(0.7777778)[3]
tournament_sim(0.7777778)[3]
tournament_sim(0.7777778)[3]
tournament_sim(0.7777778)[3]
tournament_sim(0.7777778)[3]
tournament_sim(0.7777778)[3]
tournament_sim(0.7777778)[3]
tournament_sim(0.7777778)[3]
tournament_sim(0.7777778)[3]
tournament_sim(0.7777778)[3]
tournament_sim(0.7777778)[3]
tournament_sim(0.7777778)[3]
tournament_sim(0.7777778)[3]
tournament_sim(0.7777778)[3]
tournament_sim(0.7777778)[3]
tournament_sim(0.7777778)[3]
tournament_sim(0.7777778)[3]
tournament_sim(0.7777778)[3]
tournament_sim(0.7777778)[3]
tournament_sim(0.7777778)[3]
tournament_sim(0.7777778)[3]
tournament_sim(0.7777778)[3]
tournament_sim(0.7777778)[3]
tournament_sim(0.7777778)[3]
tournament_sim(0.7777778)[3]
tournament_sim(0.7777778)[3]
tournament_sim(0.7777778)[3]
tournament_sim(0.7777778)[3]
tournament_sim(0.7777778)[3]
tournament_sim(0.7777778)[3]
tournament_sim(0.7777778)[3]
tournament_sim(0.7777778)[3]
tournament_sim(0.7777778)[3]
tournament_sim(0.7777778)[3]
tournament_sim(0.7777778)[3]
tournament_sim(0.7777778)[3]
tournament_sim(0.7777778)[3]
tournament_sim(0.7777778)[3]
tournament_sim(0.7777778)[3]
for (i in 1 : 1000) {
tournament_sim(0.7777778)[3]
}
for (i in 1 : 1000) {
print(tournament_sim(0.7777778)[3])
}
ttt <- for (i in 1 : 1000) {
tournament_sim(0.7777778)[3]
}
ttt <- c()
for (i in 1 : 1000) {
ttt [i] <- tournament_sim(0.7777778)[3]
}
ttt <- c()
for (i in 1 : 1000) {
ttt [i] <- unlist(tournament_sim(0.7777778)[3])
}
ttt
mean(ttt)
mean(ttt)
mean(ttt)
ttt <- c()
for (i in 1 : 1000) {
ttt [i] <- unlist(tournament_sim(0.7777778)[3])
}
mean(ttt)
ttt <- c()
for (i in 1 : 1000) {
ttt [i] <- unlist(tournament_sim(0.7777778)[3])
}
mean(ttt)
ttt <- c()
for (i in 1 : 1000) {
ttt [i] <- unlist(tournament_sim(0.7777778)[3])
}
mean(ttt)
ttt <- c()
for (i in 1 : 1000) {
ttt [i] <- unlist(tournament_sim(0.7777778)[3])
}
mean(ttt)
ttt <- c()
for (i in 1 : 1000) {
ttt [i] <- unlist(tournament_sim(0.7777778)[3])
}
mean(ttt)
ttt <- c()
for (i in 1 : 1000) {
ttt [i] <- unlist(tournament_sim(0.7777778)[3])
}
mean(ttt)
ttt <- c()
for (i in 1 : 100000) {
ttt [i] <- unlist(tournament_sim(0.7777778)[3])
}
mean(ttt)
0.7^7
0.3^3
(1-0.4)^3
# Generating a vector containing the win rates of interest
win_rates <- seq(from = 0.1, to = 0.90, by = 0.05)
tournament_stats_ngames <- function(n, rates = win_rates) {
# generating a matrix for storing the results
store <- matrix(nrow = length(rates), ncol=n)
# iterations i are corresponding the the number of rates the algorithm
# shall take into consideration
for (i in 1 : length(rates)) {
prob <- rates[i]
# simulating n tournaments per win rate and storing the number of matches
# played into the matrix "store"
store[i,] <- unlist(mclapply(1 : n, function(i){
as.integer(tournament_sim(p_win = prob)[1])
}, mc.cores = 6))
}
return(store)
}
rm(.Random.seed)
# simulating 10,000 tournaments per fixed win rate (variable win_rates [0.1, 0.9] is
# set as default)
table_n_matches <- tournament_stats_ngames(n = 10000)
# Generating a vector containing the win rates of interest
win_rates <- seq(from = 0.1, to = 0.90, by = 0.1)
tournament_stats_ngames <- function(n, rates = win_rates) {
# generating a matrix for storing the results
store <- matrix(nrow = length(rates), ncol=n)
# iterations i are corresponding the the number of rates the algorithm
# shall take into consideration
for (i in 1 : length(rates)) {
prob <- rates[i]
# simulating n tournaments per win rate and storing the number of matches
# played into the matrix "store"
store[i,] <- unlist(mclapply(1 : n, function(i){
as.integer(tournament_sim(p_win = prob)[1])
}, mc.cores = 6))
}
return(store)
}
rm(.Random.seed)
# simulating 10,000 tournaments per fixed win rate (variable win_rates [0.1, 0.9] is
# set as default)
table_n_matches <- tournament_stats_ngames(n = 10000)
# Generating a bootstrap function with number of straps and matrix of results
# as Input. Generates a Data.frame as Output, containing the average value of
# the sample's medians and the corresponding win rate.
bootstrap_problem_two <- function(n_straps, store){
# generating a store matrix with 9 rows (one per win rate) and one column
# per bootstrap, storing the median of the bootstrap sample
avg_storer <- matrix(nrow = 9, ncol = n_straps)
for (j in 1 : 9){ # 9 iterations (as we use 9 win rates)
#bootstrap and calculate the mean of each bootstrap sample
avg_storer[j,] <- unlist(mclapply(1 : n_straps, function(i){
mean(store[j, sample(1 : dim(store)[2], size = dim(store)[2],
replace = TRUE)])
}, mc.cores = 8))
}
# generating a vector to store the median of each row
substore <- rep(NA, 9)
# calculating the median of each row of avg_storer
for (i in 1 : 9) {
substore[i] <- mean(avg_storer[i,])
}
# binding together the win rate and its corresponding average matches per
# tournament
output <- data.frame(Prob = seq(from = 0.1, to = 0.90, by = 0.1),
average_value = substore)
return(output)
}
rm(.Random.seed)
results_2.1 <- bootstrap_problem_two(1000, table_n_matches)
results_2.1 <- results_2.1 %>%
rename(probability_theoretical = 1,
matches_played = 2)
print(results_2.1)
results_2.1 <- bootstrap_problem_two(1000, table_n_matches)
View(results_2.1)
View(results_2.1)
delta <- sapply(1:8, function(i) {
results_2.1$average_value[i+1] - results_2.1$average_value[i]
})
delta <- c(0, sapply(1:8, function(i) {
results_2.1$average_value[i+1] - results_2.1$average_value[i]
}))
rm(.Random.seed)
results_2.1 <- bootstrap_problem_two(1000, table_n_matches)
results_2.1$delta <- c(0, sapply(1:8, function(i) {
results_2.1$average_value[i+1] - results_2.1$average_value[i]
}))
results_2.1 <- results_2.1 %>%
rename(probability_theoretical = 1,
matches_played = 2)
print(results_2.1)
df_true_rates %>%
ggplot(aes(x = probability_theoretical, y = win_rate_observed))+
geom_point()+
scale_x_continuous(name="theoretical win rates", limits=c(0.1, 0.9),
n.breaks = 9)+
scale_y_continuous(name="average observed win rates", limits=c(0.0, 1.0),
n.breaks = 11)+
ggtitle("Average observed win rate in relation to a fixed theoretical win rate")+
theme(plot.title = element_text(hjust= 0.5))+
geom_abline(slope = 1, colour = "red")
(1 - 0.1)^3
(1 - 0.1)^3
(1 - 0.2)^3
(1 - 0.3)^3
(1 - 0.4)^3
(1 - 0.5)^3
(1 - 0.6)^3
(1 - 0.7)^3
(1 - 0.8)^3
(1 - 0.9)^3
(1 - 0.1)^3
(1 - 0.2)^3
(1 - 0.3)^3
(1 - 0.4)^3
(1 - 0.5)^3
(1 - 0.6)^3
(1 - 0.7)^3
(1 - 0.8)^3
(1 - 0.9)^3
(1 - 0.1)^3
(1 - 0.2)^3
(1 - 0.3)^3
(1 - 0.4)^3
(1 - 0.5)^3
(1 - 0.6)^3
(1 - 0.7)^3
(1 - 0.8)^3
(1 - 0.9)^3
p_loseall <- c()
sapply(win_rates, function(i){
p_loseall[i] <- (1 - i)^3
})
sapply(win_rates, function(i){
p_loseall <- (1 - i)^3
})
p_loseall <- c()
p_loseall <- sapply(win_rates, function(i){
(1 - i)^3
})
plot(win_rates, p_loseall)
p_loseall <- c()
p_loseall <- sapply(win_rates, function(i){
(1 - i)^3
})
df_loseall <- data.frame(win_rates, p_loseall)
View(df_loseall)
p_loseall <- c()
p_loseall <- sapply(win_rates, function(i){
(1 - i)^3
})
df_loseall <- data.frame(win_rates, p_loseall)
df_loseall %>%
ggplot(aes(x = win_rates, y = p_loseall))+
geom_point()+
xlab("theoretical win rate")+
ylab("P(n_games = 3)")
p_loseall <- c()
p_loseall <- sapply(win_rates, function(i){
(1 - i)^3
})
df_loseall <- data.frame(win_rates, p_loseall)
df_loseall %>%
ggplot(aes(x = win_rates, y = p_loseall))+
geom_point()+
scale_x_continuous(name="theoretical win rates", limits=c(0.1, 0.9),
n.breaks = 9)+
scale_y_continuous(name="P(n_games = 3)", limits=c(0, 9),
n.breaks = 9)
p_loseall <- c()
p_loseall <- sapply(win_rates, function(i){
(1 - i)^3
})
df_loseall <- data.frame(win_rates, p_loseall)
df_loseall %>%
ggplot(aes(x = win_rates, y = p_loseall))+
geom_point()+
scale_x_continuous(name="theoretical win rates", limits=c(0.1, 0.9),
n.breaks = 9)+
scale_y_continuous(name="P(n_games = 3)",
n.breaks = 9)
rm(.random.seed)
?set.seed
rm(.Random.seed)
nllk <- function(mu, sd = 25, dat = wt) {
shape <- mu^2 / sd^2
scale <- sd^2 / mu
p <- dgamma(dat, shape = shape, scale = scale, log = TRUE)
return(-sum(p))
}
grid <- seq(0.5 * mean(wt), 2 * mean(wt), length = 100)
fgrid <- sapply(grid, FUN = nllk)
plot(grid, fgrid, type = "b", pch = 19)
rug(grid)
plot(grid, fgrid, type = "b", pch = 19)
grid <- seq(0.5 * mean(wt), 2 * mean(wt), length = 100)
grid <- sapply(grid, FUN = nllk)
data(ChickWeight)
# get weights after 10 days
wt <- ChickWeight$weight[ChickWeight$Time == 10]
hist(wt)
nllk <- function(mu, sd = 25, dat = wt) {
shape <- mu^2 / sd^2
scale <- sd^2 / mu
p <- dgamma(dat, shape = shape, scale = scale, log = TRUE)
return(-sum(p))
}
grid <- seq(0.5 * mean(wt), 2 * mean(wt), length = 100)
grid <- sapply(grid, FUN = nllk)
grid <- seq(0.5 * mean(wt), 2 * mean(wt), length = 100)
fgrid <- sapply(grid, FUN = nllk)
plot(grid, fgrid, type = "b", pch = 19)
rug(grid)
?ruf
?rug
grid <- seq(0.5 * mean(wt), 2 * mean(wt), length = 100)
fgrid <- sapply(grid, FUN = nllk)
plot(grid, fgrid, type = "b", pch = 19)
rug(grid)
min(fgrid)
grid
min(fgrid) #minimum of f(x)
which.min(fgrid)
fgrid[34]
which.min(fgrid) #minimum of f(x)
grid[which.min(fgrid)]
min(fgrid)
grid[which.min(fgrid)]
plot(grid, fgrid, type = "b", pch = 19)
points(grid[min_pt], fgrid[min_pt], pch = 19, col = "firebrick")
min_pt <- which.min(fgrid) # index where f(x) reaches minimum
points(grid[min_pt], fgrid[min_pt], pch = 19, col = "firebrick")
abline(v = grid[min_pt], col = "firebrick", lwd = 2)
# left point
x_left <- 0.5 * mean(wt)
# right point
x_right <- 2 * mean(wt)
# slope at left
(nllk(x_left + 1e-8) - nllk(x_left)) / 1e-8
(nllk(x_left + 1e-8) - nllk(x_left))
# slope at right
(nllk(x_right + 1e-8) - nllk(x_right)) / 1e-8
library(numDeriv) #needed for grad() function
# INPUTS:
#  f: function to be minimized
#  left: left hand point
#  right: right hand point, assumed to have different slope sign from left point
#  tol: error tolerance
#  print: print intervals as you go
# OUTPUTS:
#  mid point of final interval
bisect <- function(f, left, right, tol = 1e-8, print = TRUE) {
width <- right - left
# get slopes at each side
slope_left <- grad(f, left)
slope_right <- grad(f, right)
while (width > tol) {
if (print) cat("interval: (", left, " , ", right, ")\n")
# get slope at mid point
mid <- (left + right) / 2
slope_mid <- grad(f, mid)
if (slope_mid * slope_left > 0) {
# left and mid have same sign of slope
left <- mid
slope_left <- slope_mid
} else {
# right and mid have same sign of slope
right <- mid
slope_right <- slope_mid
}
width <- right - left
}
return((left + right) / 2)
}
opt_bisect <- bisect(nllk, 0.5 * mean(wt), 2 * mean(wt), print = FALSE)
opt_bisect
# Newton's method in 1D
# INPUTS:
#  f: function to opimize
#  theta: starting value
#  tol: error tolerance
#  print: print out iterations?
# OUTPUT:
#  optimal parameter value
newton <- function(f, theta, tol = 1e-10, print = TRUE) {
# set starting value
par <- theta
step <- Inf
# stop when step is smaller than tolerance
while (abs(step) > tol) {
if (print) cat("par: ", par, "\n")
# use Newton's updating step
step <- -grad(f, par) / hessian(f, par)
par <- par + step
}
return(par)
}
newton(nllk, 100)
?hessian
exp(2)
exp(1)
?exp()
exp(0)
plot(rad$time, rad$count, type = "b", pch = 20, xlab = "Time", ylab = "Radiation")
